wait(2) repeat wait() until game:GetService("Players").LocalPlayer ~= nil function GetLastChildOfClass(Par, Ty) local Item = nil for i, v in pairs(Par:GetChildren()) do if v:IsA(Ty) then Item = v end end return Item end function GetChildOfClassAtIndex(Par, Ty, Ind) local ItemNumber = 0 for i, v in pairs(Par:GetChildren()) do if v:IsA(Ty) then ItemNumber = ItemNumber + 1 if ItemNumber == Ind then return v end end end end function GetAllChildrenOfClass(Par, Ty) local ItemTab = {} for i, v in pairs(Par:GetChildren()) do if v:IsA(Ty) then table.insert(ItemTab, v) end end return ItemTab end function GetLastChildOfParent(Par) items = Par:GetChildren() return item[#items] end SpecialNameCalls = {["GetLastChildOfClass"] = GetLastChildOfClass, ["GetChildOfClassAtIndex"] = GetChildOfClassAtIndex, ["GetAllChildrenOfClass"] = GetAllChildrenOfClass, ["GetLastChildOfParent"] = GetLastChildOfParent} if nc == nil then getgenv().meta = getrawmetatable(game) getgenv().nc = meta.__namecall getgenv().id = meta.__index getgenv().ne = meta.__newindex StoredItemTable = {} LockedVals = {} OnIndexed = {} OnNewIndexed = {} getgenv().LockProperty = function(Item, Property, Val) if LockedVals[Item] == nil or typeof(LockedVals[Item]) ~= "table" then LockedVals[Item] = {} end if Val == nil then LockedVals[Item][Property] = true else LockedVals[Item][Property] = nil end end SpoofedVals = {} getgenv().SpoofProperty = function(Item, Property, Val, Bool) if SpoofedVals[Item] == nil then SpoofedVals[Item] = {} end if Bool == nil then SpoofedVals[Item][Property] = Val else SpoofedVals[Item][Property] = nil end end getgenv().AddNamecall = function(Call, f) SpecialNameCalls[Call] = f end getgenv().NewOnIndexed = function(Item, Property, F) if OnIndexed[Item] == nil then OnIndexed[Item] = {} end if OnIndexed[Item][Property] == nil then OnIndexed[Item][Property] = {} end local T; local function Delete() for i = 1, #OnIndexed[Item][Property] do if OnIndexed[Item][Property][i] == T then table.remove(OnIndexed[Item][Property], i) end end end T = setmetatable({["Delete"] = Delete, ["Remove"] = Delete, ["delete"] = Delete, ["remove"] = Delete, ["disconnect"] = Delete, ["Disconnect"] = Delete}, {__call = F}) table.insert(OnIndexed[Item][Property], T) return T end getgenv().NewOnNewIndexed = function(Item, Property, F) if OnNewIndexed[Item] == nil then OnNewIndexed[Item] = {} end if OnNewIndexed[Item][Property] == nil then OnNewIndexed[Item][Property] = {} end local T; local function Delete() for i = 1, #OnNewIndexed[Item][Property] do if OnNewIndexed[Item][Property][i] == T then table.remove(OnNewIndexed[Item][Property], i) end end end T = setmetatable({["Delete"] = Delete, ["Remove"] = Delete, ["delete"] = Delete, ["remove"] = Delete, ["disconnect"] = Delete, ["Disconnect"] = Delete}, {__call = F}) table.insert(OnNewIndexed[Item][Property], T) return T end setreadonly(meta, false) meta.__namecall = newcclosure(function(rc, ...) local args = {...} if #args > 0 and tostring(args[#args]) == "BCheck" then table.remove(args, #args) return nc(rc, unpack(args)) elseif StoredItemTable[rc] ~= nil and StoredItemTable[rc][getnamecallmethod()] ~= nil then return (StoredItemTable[rc][getnamecallmethod()])(unpack(args)) elseif (StoredItemTable[rc] ~= nil or LockedVals[rc] ~= nil or SpoofedVals[rc] ~= nil) and string.lower(getnamecallmethod()) == "clone" then local TempOb = nc(rc, unpack(args)) if StoredItemTable[rc] ~= nil then StoredItemTable[TempOb] = {} for i, v in pairs(StoredItemTable[rc]) do StoredItemTable[TempOb][i] = v end end if LockedVals[rc] ~= nil then LockedVals[TempOb] = LockedVals[rc] if typeof(LockedVals[rc]) == "table" then LockedVals[TempOb] = {} for i, v in pairs(LockedVals[rc]) do LockedVals[TempOb][i] = v end end end if SpoofedVals[rc] ~= nil then SpoofedVals[TempOb] = {} for i, v in pairs(SpoofedVals[rc]) do SpoofedVals[TempOb][i] = v end end return TempOb elseif SpecialNameCalls[getnamecallmethod()] ~= nil then return SpecialNameCalls[getnamecallmethod()](rc, unpack(args)) end return nc(rc, unpack(args)) end) meta.__index = newcclosure(function(rc, ...) local args = {...} if OnIndexed[rc] and OnIndexed[rc][args[1]] then for i = 1, #OnIndexed[rc][args[1]] do local v = OnIndexed[rc][args[1]][i](rc, args[1]) if v then return end end end if StoredItemTable[rc] ~= nil and StoredItemTable[rc][args[1]] ~= nil then return StoredItemTable[rc][args[1]] elseif SpoofedVals[rc] ~= nil and SpoofedVals[rc][args[1]] ~= nil and syn_context_get() < 6 then return SpoofedVals[rc][args[1]] end return id(rc, unpack(args)) end) function Check(Ob, Val, S) local V = pcall(function() return ne(Ob, Val, S) end) return V end meta.__newindex = newcclosure(function(rc, ...) if typeof(rc) == "table" then return ne(rc, ...) end local args = {...} if OnNewIndexed[rc] and OnNewIndexed[rc][args[1]] then for i = 1, #OnNewIndexed[rc][args[1]] do OnNewIndexed[rc][args[1]][i](rc, args[1], args[2]) end end if syn_context_get() >= 6 and args[1] ~= nil and Check(rc, args[1], args[2]) == false and args[1] ~= "RLocked" then if StoredItemTable[rc] == nil then StoredItemTable[rc] = {} end StoredItemTable[rc][args[1]] = args[2] return args[2] elseif syn_context_get() >= 6 and args[1] == "RLocked" then if args[2] == true then LockedVals[rc] = true else LockedVals[rc] = nil end return args[2] elseif syn_context_get() < 6 and args[1] ~= nil and (LockedVals[rc] ~= nil and typeof(LockedVals[rc]) ~= "table" or LockedVals[rc] ~= nil and LockedVals[rc][args[1]] ~= nil) then return end return ne(rc, ...) end) end game.Players.LocalPlayer.Kick = function() wait(2e9) return "You waited a long time huh?" end getgenv().GetStacks = function() local Tab = {} pcall(function() local i = 0 while true do table.insert(Tab, getfenv(i)) i = i + 1 end end) return Tab end local Fenvs = {} local FuncsCalls = {} local stmt = setrawmetatable local tbin = table.insert local fnv = getfenv local pcl, unp = pcall, unpack; local NotAllowedFunctions = {getrawmetatable = true, setrawmetatable = true, tbin = true, getfenv = true} local FF = function() tostring("") end local FakeFunctions = {["print"] = FF, ["warn"] = FF, ["error"] = FF} local StoredPrint = getrenv().print local StoredRbx = {} local tpf = typeof function ConvertTableToString(...) local Tab = {...} local S = "" for i = 1, #Tab do local s = false if tpf(Tab[i]) == "string" then S = S..'"' s = true end S = S..tostring(Tab[i]) if s then S = S..'"' end if i ~= #Tab then S = S..", " end end return S end for i, v in pairs(getrenv()) do if i ~= "__index" and not FakeFunctions[i] then StoredRbx[i] = v elseif FakeFunctions[i] then StoredRbx[i] = FakeFunctions[i] end end local StoredFuncs = {} local LogArgs = false local TempTab = setmetatable({}, {__index = newcclosure(function(Tab, Val) tbin(FuncsCalls[fnv(2)], Val) return StoredRbx[Val] end)}) local FakeTables = {} function SetupTable(Indx, Tab) if not FakeTables[Indx] then FakeTables[Indx] = {} stmt(FakeTables[Indx], {__index = newcclosure(function(T, Val) tbin(FuncsCalls[fnv(2)], Val) if not StoredFuncs[Tab[Val]] then StoredFuncs[Tab[Val]] = function(...) tbin(FuncsCalls[fnv(2)], ConvertTableToString(...)) return Tab[Val](...) end end if LogArgs then return StoredFuncs[Tab[Val]] end return Tab[Val] end)}) end end FakeFunctions["getrenv"] = function() return TempTab end getgenv().StackCheck = function(F, ...) LogArgs = false if NotAllowedFunctions[F] then return {} end local Fenv = getfenv(F) FuncsCalls[Fenv] = {} if not Fenvs[Fenv] then Fenvs[Fenv] = getrawmetatable(Fenv) end local mt; local indx = function(Tab, Val) tbin(FuncsCalls[Fenv], Val) if Tab == Fenv and not FakeFunctions[Val] and tpf(Fenvs[Fenv].__index[Val]) ~= "table" then return Fenvs[Fenv].__index[Val] elseif FakeFunctions[Val] then return FakeFunctions[Val] elseif typeof(Fenvs[Fenv].__index[Val]) == "table" then SetupTable(Val, Fenvs[Fenv].__index[Val]) return FakeTables[Val] else return rawget(Tab, Val) end end stmt(Fenv, {__index = indx}) local Args = {...} local B, Ret = pcl(function() return {F(unp(Args))} end) stmt(Fenv, Fenvs[Fenv]) Fenvs[Fenv] = nil if B == false then print("Error: "..tostring(Ret)) end return FuncsCalls[Fenv], B end getgenv().StackCheckWithArgs = function(F, ...) LogArgs = true if NotAllowedFunctions[F] then return {} end local Fenv = getfenv(F) FuncsCalls[Fenv] = {} if not Fenvs[Fenv] then Fenvs[Fenv] = getrawmetatable(Fenv) end local mt; local indx = function(Tab, Val) tbin(FuncsCalls[Fenv], Val) if Tab == Fenv and not FakeFunctions[Val] and tpf(Fenvs[Fenv].__index[Val]) ~= "table" then if tpf(Fenvs[Fenv].__index[Val]) == "function" then if not StoredFuncs[Fenvs[Fenv].__index[Val]] then StoredFuncs[Fenvs[Fenv].__index[Val]] = function(...) tbin(FuncsCalls[Fenv], "("..ConvertTableToString(...)..")") return Fenvs[Fenv].__index[Val](...) end end return StoredFuncs[Fenvs[Fenv].__index[Val]] end return Fenvs[Fenv].__index[Val] elseif FakeFunctions[Val] then return FakeFunctions[Val] elseif typeof(Fenvs[Fenv].__index[Val]) == "table" then SetupTable(Val, Fenvs[Fenv].__index[Val]) return FakeTables[Val] else return rawget(Tab, Val) end end stmt(Fenv, {__index = indx}) local Args = {...} local B, Ret = pcl(function() return {F(unp(Args))} end) stmt(Fenv, Fenvs[Fenv]) Fenvs[Fenv] = nil if B == false then print("Error: "..tostring(Ret)) end LogArgs = false return FuncsCalls[Fenv], B end getgenv().PrintStack = function(...) print("--------U--------") local Funcs = StackCheck(...) print("--------D--------") for i = 1, #Funcs do print(Funcs[i]) end end getgenv().PrintStackWithArgs = function(...) print("--------U--------") local Funcs = StackCheckWithArgs(...) print("--------D--------") for i = 1, #Funcs do print(Funcs[i]) end end getgenv().StoreTools = function(...) args = {...} for i, v in pairs(game.Players.LocalPlayer.Backpack:GetChildren()) do local Open = true for a = 1, #args do if v.Name == args[a] then Open = false break end end if Open == true then v.Parent = game.Players.LocalPlayer end end end getgenv().UnStore = function() for i, v in pairs(game.Players.LocalPlayer:GetChildren()) do if v:IsA("Tool") then v.Parent = game.Players.LocalPlayer.Backpack end end end getgenv().TimeFunction = function(F, ...) local Start = tick() F(...) return tick()-Start end function AvoidCrasher(Fenv, F) for i, v in pairs(Fenv) do if i == "script" and typeof(v) == "Instance" and v.ClassName == F.ClassName and F == v then return true end end return false end function LoopThroughTable(Tab, F, LookThrough) for i, v in pairs(LookThrough) do if typeof(v) == "function" and islclosure(v) and getfenv(v) and AvoidCrasher(getfenv(v), F) then table.insert(Tab, v) end end end getgenv().GetFunctionsFromScript = function(F) local functionstab = {} LoopThroughTable(functionstab, F, getgc()) LoopThroughTable(functionstab, F, debug.getregistry()) return functionstab end local IgnoredTypes = {["boolean"] = true, ["number"] = true, ["function"] = true, ["Instance"] = true} function FilterConstants(Consts) local RealConstants = {} for i = 1, #Consts do local Original = Consts[i] Consts[i] = tostring(Consts[i]) if IgnoredTypes[typeof(Original)] == nil and not ((string.sub(Consts[i], 1, 1) == "p" or string.sub(Consts[i], 1, 1) == "u" or string.sub(Consts[i], 1, 1) == "v") and tonumber(string.sub(Consts[i], 2)) ~= nil) then if string.sub(Consts[i], 1, 3) ~= "l__" and string.len(Consts[i]) > 0 and (string.sub(Consts[i], 1, 4) ~= "Enum" or string.len(Consts[i]) > 4) then table.insert(RealConstants, Consts[i]) end end end return RealConstants end function Replace(Str, What, Rep) local StrTab = string.split(Str, What) local NewS = StrTab[1] if #StrTab > 1 then for i = 2, #StrTab do NewS = NewS..Rep..StrTab[i] end end return NewS end setreadonly(string, false) string.replace = Replace setreadonly(string, true) function MatchTable(Tab1, Tab2) local IsMatched = true for i = 1, #Tab1 do local Found = false for a = 1, #Tab2 do if string.match(tostring(Tab2[a]), tostring(Tab1[i])) then Found = true break end end if Found == false then IsMatched = false break end end return IsMatched end getgenv().StringDecompile = function(Script) local DecompString = decompile(Script) local Funcs = GetFunctionsFromScript(Script) local FuncsConsts = {} local ReturnedFunction; if pcall(function() ReturnedFunction = loadstring(DecompString) end) == false then setclipboard(DecompString) return DecompString end local RetFuncsConsts = {} if not typeof(ReturnedFunction) == "function" then setclipboard(DecompString) return DecompString end for i, v in pairs(debug.getprotos(ReturnedFunction)) do if debug.getinfo(v).name ~= "" then RetFuncsConsts[debug.getinfo(v).name] = FilterConstants(debug.getconstants(v)) end end for i, v in pairs(Funcs) do local N = i if debug.getinfo(v).name ~= "" then N = debug.getinfo(v).name end FuncsConsts[N] = FilterConstants(debug.getconstants(v)) end local Matched = {} for i, v in pairs(RetFuncsConsts) do for a, b in pairs(FuncsConsts) do if #v > 0 and #b > 0 and MatchTable(v, b) and MatchTable(b, v) then Matched[i] = a end end end local Dupes = {} for i, v in pairs(Matched) do if Dupes[i] == nil then Dupes[i] = true else Dupes[i] = false end if Dupes[v] == nil then Dupes[v] = true else Dupes[v] = false end end local ConvertedStr = "" local Last = 1 local AlreadyPrinted = {} local ThingsToLookFor = {" ", "(", ",", "\n"} for i, v in pairs(Matched) do if Dupes[i] ~= false and Dupes[v] ~= false then for a = 1, #ThingsToLookFor do DecompString = Replace(DecompString, tostring(i)..ThingsToLookFor[a], tostring(v)..ThingsToLookFor[a]) end end end ConvertedStr = ConvertedStr..string.sub(DecompString, Last) setclipboard(ConvertedStr) 
